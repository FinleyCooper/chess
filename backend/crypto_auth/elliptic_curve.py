from hashlib import sha512
from math import log2, ceil
from random import SystemRandom


# Valid for elliptic curves defined on curved with 512 bits or less (as we are using sha512 so our max hash length is 512 bits)
# Not valid for any elliptic curves with the constant, b, != 0. <class>.point_at_infinity must be changed to a point not on the curve
class EllipticCurve:
    HASH_LENGTH: int = 512

    def __init__(self, name: str, p: int, a: int, b: int, G: tuple, n: int) -> None:
        self.name = name

        # The order of the Galois field that the curve is defined in
        self.p = p

        # Data about the curve y^2 = x^3 + ax + b
        self.a = a  # Coeffient of the x term
        self.b = b  # Constant term

        # Generator point that generates the cyclic subgroup order n
        self.G = G
        # Order of the group generated by G
        self.n = n

        # Bitlength of the order of the subgroup generated by G
        self.n_bitlength = ceil(log2(n))

        # We define ğ’ª to take the value (0, 0) (not on the curve if b != 0) with the condition that âˆ€ zâˆˆâŸ¨GâŸ©, z + ğ’ª = z, ğ’ª + z = z, z + (-z) = ğ’ª, ğ’ª + ğ’ª = ğ’ª
        assert b != 0
        self.point_at_infinity = (0, 0)

    def generate_key_pair(self):
        # Private key in the open inteval (0, n)
        private_key = SystemRandom().randrange(1, self.n)

        # private key x G = public key, so the public key is the 'private_key'th element in the group generated by G
        (x, y) = self.scalar_multiplication(private_key, self.G)
        public_key = (x << self.n_bitlength) ^ y

        print(
            "\n------BEGIN PRIVATE KEY-----\nCURVE: "
            + str(self.name)
            + " ("
            + str(self.n_bitlength * 2)
            + " bits)\n"
            + str(private_key)
            + "\n------END PRIVATE KEY-----"
        )
        print(
            "\n\n------BEGIN PUBLIC KEY-----\nCURVE: "
            + str(self.name)
            + " ("
            + str(self.n_bitlength)
            + " bits)\n"
            + str(public_key)
            + "\n------END PUBLIC KEY-----"
        )

    def point_addition(self, p: tuple, q: tuple) -> tuple:
        if p == self.point_at_infinity:
            return q
        if q == self.point_at_infinity:
            return p

        # Check if the x coordinates match
        if p[0] == q[0]:
            # Check if the y coordinates match too, then they are the same point, otherwise p and q are inverses, q = -p
            if p[1] == q[1]:
                return self.point_double(p)
            else:
                return self.point_at_infinity

        # Formula from Wikipedia
        # Gradient of the line intersecting p and q
        gradient = ((p[1] - q[1]) * pow(p[0] - q[0], -1, self.p)) % self.p

        x = (gradient**2 - p[0] - q[0]) % self.p
        y = (gradient * (p[0] - x) - p[1]) % self.p

        return (x, y)

    def point_double(self, p: tuple) -> tuple:
        if p == self.point_at_infinity:
            return p
        # We do the the same, but we must use calculus to find the gradient at p using the equation of the line
        # y^2 = x^3 + ax + b

        # Using implicit differentitation
        # d/dx(y^2) = 3x^2 + a
        # dy/dx (2y) = 3x^2 + a
        # dy/dx = (3x^2 + a) / 2y

        gradient = ((3 * p[0] ** 2 + self.a) * pow(2 * p[1], -1, self.p)) % self.p

        x = (gradient**2 - 2 * p[0]) % self.p
        y = (gradient * (p[0] - x) - p[1]) % self.p

        return (x, y)

    def scalar_multiplication(self, scalar: int, point: tuple) -> tuple:
        # Go bit by bit
        mask = 0b1

        # Point which is doubled for each iteratation
        doubler = point

        # If scalar = 0, we return ğ’ª, otherwise this total is replaced as âˆ€ zâˆˆâŸ¨GâŸ©, z + ğ’ª = z
        total = self.point_at_infinity

        while scalar >= mask:
            if mask & scalar:
                total = self.point_addition(total, doubler)

            doubler = self.point_double(doubler)
            # Shift mask left by one bit
            mask <<= 1

        return total

    def createSignature(self, binary: bytes, private_key: int) -> int:
        # General steps from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-5.pdf
        # Section 6.4.1 ECDSA Signature Generation Algorithm
        full_hash = int.from_bytes(sha512(binary, usedforsecurity=True).digest(), "big")

        # We want only the n_bitlength left bits of the hash
        hash = full_hash >> (self.HASH_LENGTH - (self.n_bitlength + 1))

        while True:
            # Cryptographically secure integer, in the open inteval (0, n)
            k = SystemRandom().randrange(1, self.n)

            # new point is random point in the group âŸ¨GâŸ©
            new_point = self.scalar_multiplication(k, self.G)
            r = new_point[0] % self.n

            s = ((hash + (r * private_key)) * pow(k, -1, self.n)) % self.n

            if s != 0 and r != 0:
                break  # This will destory k, as when we leave the scope, k has no more references, so will be cleared by the garbage collector

        # Concatinate the binary strings of r and s with bitlength bitlength_n and return this as the signature (as we know that r and s have been calculated modulo n)
        return r ^ (s << self.n_bitlength)

    def verifySignature(self, binary: bytes, signature: int, public_key_int: int) -> int:
        # General steps from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-5.pdf
        # Section 6.4.2 ECDSA Signature Verification Algorithm
        public_key = (public_key_int >> self.n_bitlength, public_key_int & ((2**self.n_bitlength - 1)))

        if public_key == self.point_at_infinity:
            return False

        # Check if the public_key satisfies y^2 = x^3 + ax + b (mod p)
        if (public_key[1] ** 2) % self.p != (public_key[0] ** 3 + self.a * public_key[0] + self.b) % self.p:
            return False

        # If pkâˆˆâŸ¨GâŸ© then 0 x pk = ğ’ª which implies n x pk = ğ’ª as n are 0 and congurant modulo n (as the group generated by G is cyclic)
        if self.scalar_multiplication(self.n, public_key) != self.point_at_infinity:
            return False

        r = signature & (2**self.n_bitlength - 1)
        s = signature >> self.n_bitlength

        # check that r and s are in the open inteval (0, n)
        if r < 1 or r >= self.n or s < 1 or s >= self.n:
            return False

        full_hash = int.from_bytes(sha512(binary, usedforsecurity=True).digest(), "big")

        # We want only the n_bitlength left bits of the hash
        hash = full_hash >> (self.HASH_LENGTH - (self.n_bitlength + 1))

        multiplicative_inverse_s = pow(s, -1, self.n)

        u = (hash * multiplicative_inverse_s) % self.n
        v = (r * multiplicative_inverse_s) % self.n

        (r1, _) = self.point_addition(self.scalar_multiplication(u, self.G), self.scalar_multiplication(v, public_key))

        if r == (r1 % self.n):
            return True
        else:
            return False


# Curve chosen arbitrarily from http://www.secg.org/sec2-v2.pdf
# Parameters from secp256r1 in the artical
# secp256r1 is defined over a finite field with an odd prime order, not a binary field.
curve = EllipticCurve(
    name="secp256r1",
    p=115792089210356248762697446949407573530086143415290314195533631308867097853951,
    a=115792089210356248762697446949407573530086143415290314195533631308867097853948,
    b=41058363725152142129326129780047268409114441015993725554835256314039467401291,
    G=(
        48439561293906451759052585252797914202762949526041747995844080717082404635286,
        36134250956749795798585127919587881956611106672985015071877198253568414405109,
    ),
    n=115792089210356248762697446949407573529996955224135760342422259061068512044369,
)

if __name__ == "__main__":
    curve.generate_key_pair()
